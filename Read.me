1.Java的Collection和Map：如何实现key-Value的LRU缓存？
    1.1 面试题
        * 请用Iterator实现一个随机序列产生器
        * Collection和Set的区别
        * Map是不是Collection
        * TreeMap和HashMap的区别
        * HashMap vs Hashtable
        * 实现key-value的LRU缓存
    1.2 容器Collection
        * 容纳数据的容器 （一组group对象，提供增删改，遍历Iterator）
        * Iterator - coding
        * Collection接口 - 源代码阅读
        * 集合Set<E>
            内容不重复的容器
            实现
               - ConcurrentSkipListSet - 跳表
               - CopyOnWriteArraySet
               - EnumSet - 位运算
               - Hashset
               - ImmutableCollection.SetN
               - LinkedHashSet
               - TreeSet - 树
            Null Object
                - TreeSet 不允许（因为元素必须是Comparable）
                - HashSet 允许
    1.3 映射
        * 两个集合的对应关系 - key -> value
        * 实现 HashMap、TreeMap、Hashtable、SortedMap
        * Map是不是Entry容器
            Entry<k,v>是一个key,value集合
            阅读Entry源码思考结论
        * Map<K,V>接口
        * Map的实现
            ConcurrentHashMap、HashMap、Hashtable、LinkedHashMap是基于哈希表的实现
            TreeMap是基于树的实现
            ConcurrentSkipListMap是基于跳表的实现
            EnumMap是基于位运算的实现
        * HashMap vs HashTable
            对比源码
            HashMap运行null,HashTable不允许
        * LinkedHashMap
            实现LRUCache

--------------------------------------------------------------------------------------------------------------------------------------------
2.Java8 Stream<T>接口：流和并发计算实例
    2.1 面试题
        * 什么是流
        * ::运算符的作用？
        * Java 8的stream价值是什么？
        * 创建Stream有几种方法
        * coding：利用parallel并发执行任务
    2.2 Java8 Stream
        * 为一组序列提供顺序、并行计算
            流：随着时间产生的数据序列
            特点：1.支持函数式编程 2.提供管道运算能力 3.提供并发并行计算能力 4.提供大量的操作
        * 提供流计算
            source(数据源) -> map(操作) -> filter(操作) -> reduce(终止操作)
            pipeline的过程
            操作
                状态：有状态（sorted、skip、limit）无状态(map、reduce)
                副作用：纯函数、非纯函数
        * 提供并发计算

3.函数式编程
    3.1 面试题
        * Option<T>作用
        * FunctionalInterface在做什么
        * 说说你理解的函数式编程
        * 解释下什么是Monad？
        * 如何实现管道和流


---------------------------------------------------------------------------------------------------------------------------------------------
4.Buffer的原理和使用场景
    4.1 引入
        1. 流 vs 缓冲区
            1.1 流：随着时间来的数据
            1.2 缓冲区：缓冲作用 （按键太快、磁盘写入操作太多、网络请求太多）
            1.3 缓冲的本质是排队、流的本质是数据
    4.2 面试题
        1. 缓冲区是不是流
        2. 缓冲区的几种操作含义
        3. 缓冲区设置多大
        4. NIO的Channel比缓冲区快吗
        5. 缓冲过程中，中文乱码如何处理
        6. 并发分析数据更快吗
        7. 计算一个大文件的词频
    4.3 I/O的成本
        1. Device ->(copy*2) Channel ->(copy) Buffer ->(copy) Thread   Device -> kernelSpace -> UserSpace
            1.1 处理一个文件，从设备到现场之间，IO成本为什么高呢？假如我们信息到设备了，这个设备可能是网卡，这个网卡收到了这个请求，第一步，网卡先把数据拷贝到操作系统的内核空间，这种拷贝是DMA来做的，不经过CPU直接将数据copy到内核空间，这一步
            copy是不消耗cpu的，内核空间接收到数据之后，如果线程要用(线程能用的数据都在用户空间)，再把数据copy到用户空间缓冲区,在Java NIO当中，做了抽象抽象出了channel,数据到了userSpace,以Buffer的形式
            到用户空间，buffer是一个二进制的数组，线程要用，数据要从buffer中读出来，读取数据又是一次copy


































